<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>muduo源码解析：EventLoop - dejavudwh&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=muduo,源码解析>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="dejavudwh&#39;s blog" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.1.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">dejavudwh&#39;s blog</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/tags" class="menu-item-link">tags</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">about</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">muduo源码解析：EventLoop</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2022-05-07</span>
  </div>
  <div class="post-content">
    <p>本系列文章主要对muduo的核心源码进行解析。</p>
<p>在正式看muduo源代码之前，必须先理解Reactor模型。</p>
<h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>1服务器端程序一般要处理三类事件：IO事件、信号及定时事件，由此延申出来的就有两种关于如何处理这三类事件的事件处理模型：Reactor和Proactor。这里主要讨论Reactor。</p>
<p>Reactor模型本质上主线程***（main reactor)***只负责监听Socket fd上是否有事件发生，有的立即通知工作线程进行处理，也就是说接受新连接、读写数据，业务逻辑均在工作线程中。</p>
<p>使用同步IO模型<em><strong>（以epoll为例）</strong></em>实现的Reactor模型的工作流程是：</p>
<ul>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上可读事件发生时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列，由工作线程进行消费。</li>
<li>工作线程从socket上读取数据，处理业务逻辑，然后往epoll内核事件表上注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上可写事件发生时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列，由工作线程进行消费。</li>
<li>工作线程向socket写入响应消息。</li>
</ul>
<p>所以Reactor模型一般包含几个组件：句柄（Handle)、事件多路分发器（EventDmultiplexer)、事件处理器（EventHandler）和Reactor。</p>
<p>Reactor是整个框架的核心，Reactor执行事件循环，由用户通过Reactor向事件多路分发器注册事件，句柄也就是统一事件源，当内核检测到就绪事件时，它将通过句柄来通知事件，再由事件多路分发器通过epoll_wait等来分发事件到Reactor，最后再由Reactor调用相应的事件处理器。</p>
<h3 id="muduo的事件模型"><a href="#muduo的事件模型" class="headerlink" title="muduo的事件模型"></a>muduo的事件模型</h3><p>muduo的事件模型是<code>one loop per thread + threadpool</code>。</p>
<p><img src="https://raw.githubusercontent.com/dejavudwh/dejavudwh.github.io/picbed/muduo/20200522172245614.png"></p>
<p>也就是说，在多线程下，muduo的每一个子线程都会有一个由mainReactor创建的subReactor，也就是一个事件循环，而其中的被分配到subReactor的socket中的事件和业务逻辑也都由subReactor的子线程进行处理。</p>
<p>所以在多线程下，muduo的工作流程和上面所说的流程的主要区别是：</p>
<ul>
<li>主线程的事件循环中只监听新连接的事件，并且将新连接根据Round-Robin分配到subReactor中的事件循环。</li>
<li>在此后由该socket触发的事件包括计算任务都由当前subReactor进行处理。</li>
</ul>
<hr>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>和事件循环相关的类主要有Channel、Acceptor、Poller、EventLoop。Channel是其它类的基础，所以先来分析一个Channel这个类。</p>
<p>Channel主要是对fd和统一事件源及其对应的事件处理的封装。1</p>
<p>Channel的成员变量如下，意义都比较明显，<code>index_</code>和<code>tied_</code>后面分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;    <span class="comment">// 所属的EvenLoop对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  fd_;	   <span class="comment">// 文件描述符，但不负责关闭该文件描述符</span></span><br><span class="line"><span class="type">int</span>        events_;  <span class="comment">// 关注的事件</span></span><br><span class="line"><span class="type">int</span>        revents_; <span class="comment">// 返回的事件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>        index_; </span><br><span class="line"><span class="type">bool</span>       logHup_;   </span><br><span class="line"></span><br><span class="line">boost::weak_ptr&lt;<span class="type">void</span>&gt; tie_;  <span class="comment">// 弱引用，void可以接收任何类型，用于生命周期管理。</span></span><br><span class="line"><span class="type">bool</span> tied_; </span><br><span class="line"><span class="type">bool</span> eventHandling_;    <span class="comment">// 是否处于事件处理中</span></span><br><span class="line"><span class="type">bool</span> addedToLoop_;	 	 </span><br><span class="line">ReadEventCallback readCallback_; <span class="comment">// 事件处理回调</span></span><br><span class="line">EventCallback writeCallback_;</span><br><span class="line">EventCallback closeCallback_;</span><br><span class="line">EventCallback errorCallback_;</span><br></pre></td></tr></table></figure>

<p>Channel的成员函数最重要的就是事件处理函数<code>handleEvent</code>和设置和取消所关注的事件的一些系列函数<code>enable...()</code>和<code>disable...()</code>。</p>
<h3 id="handleEvent"><a href="#handleEvent" class="headerlink" title="handleEvent"></a>handleEvent</h3><p>我们要知道，Channel封装的是fd和事件及其事件处理回调，所以显然<code>handleEvent</code>会被在例如epoll_wait返回之后的事件循环中调用，看一下源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">  <span class="keyword">if</span> (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.<span class="built_in">lock</span>();   </span><br><span class="line">    <span class="keyword">if</span> (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">	  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tie</code>和<code>tied_</code>在这里就发挥了作用，它的作用就是延长Channel的生命周期，详细我们仍然按住不表，到后面分析TCPConnection的时候再看。</p>
<p>所以这里会继续调用<code>handleEventWithGuard</code>，逻辑也会很清晰，即根据事件来调用回调函数。1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  eventHandling_ = <span class="literal">true</span>;      </span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="built_in">reventsToString</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (logHup_)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="string">&quot; Channel::handle_event() POLLHUP&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (closeCallback_) <span class="built_in">closeCallback_</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; POLLNVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; fd_ &lt;&lt; <span class="string">&quot; Channel::handle_event() POLLNVAL&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errorCallback_) <span class="built_in">errorCallback_</span>();   <span class="comment">//错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (readCallback_) <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; POLLOUT)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (writeCallback_) <span class="built_in">writeCallback_</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  eventHandling_ = <span class="literal">false</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="update和remove"><a href="#update和remove" class="headerlink" title="update和remove"></a>update和remove</h3><p>接下来比较重要的函数就是<code>update</code>和<code>remove</code>，根据函数名字显然易见，一个是更新关注的事件，一个是移除当前Channl（也就是不关注所有事件了）。</p>
<p>其中<code>update</code>函数在<code>enable...()</code>和<code>diable...()</code>系列函数之后调用，也就是先对更改事件，然后再真正的去内核事件表中进行更新，省掉一些重复代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; events_ |= kReadEvent; <span class="built_in">update</span>(); &#125;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123; events_ &amp;= ~kReadEvent; <span class="built_in">update</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">  loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">isNoneEvent</span>());</span><br><span class="line">  addedToLoop_ = <span class="literal">false</span>;</span><br><span class="line">  loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里更新和删除Channel最后都是调用EventLoop的函数，其中EventLoop再去调用Poller提供的接口。所以接下来看一下Poller类。</p>
<h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>在muduo里提供了epoll和poll来做多路复用，默认使用epoll。所以Poller类是这两个类的父类，这里我们主要关注EPollPoller。</p>
<p>EPollPoller的设计非常简洁，接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EPollPoller</span> : <span class="keyword">public</span> Poller</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EPollPoller</span>(EventLoop* loop);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">EPollPoller</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList* activeChannels)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:  </span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>;  </span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">operationToString</span><span class="params">(<span class="type">int</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ChannelList* activeChannels)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation, Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; EventList;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> epollfd_;</span><br><span class="line">  EventList events_;   <span class="comment">//事件数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口的含义都非常明显，其中<code>poll</code>就是相当于调用<code>epoll_wait</code>等待事件返回，由EventLoop调用，然后通过<code>fillActiveChannels</code>去填充EventLoop传进来的activeChannels，而EventLoop则根据这个List去处理回调。</p>
<p>先来看<code>removeChannel</code>操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Poller::<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; fd;</span><br><span class="line">  <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">assert</span>(channels_[fd] == channel);</span><br><span class="line">  <span class="built_in">assert</span>(channel-&gt;<span class="built_in">isNoneEvent</span>());</span><br><span class="line">  <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">  <span class="built_in">assert</span>(index == kAdded || index == kDeleted);</span><br><span class="line">  <span class="type">size_t</span> n = channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line">  (<span class="type">void</span>)n;</span><br><span class="line">  <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index == kAdded)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">  &#125;</span><br><span class="line">  channel-&gt;<span class="built_in">set_index</span>(kNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑非常的清晰，先从Poller所持有的channels_删除当前Channel，再从epoll中删除当前channel关注的事件。这里就可以体现之前Channel中index的作用了，主要用来标志当前的Channel是新添加、被删除还是一个正在监听的Channel。注意，这里的remove并不会真正的删除channel，这里后面再解释。</p>
<p>再看<code>updateChannel</code>和<code>update</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Poller::<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">fd</span>()</span><br><span class="line">    &lt;&lt; <span class="string">&quot; events = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">events</span>() &lt;&lt; <span class="string">&quot; index = &quot;</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index == kNew || index == kDeleted)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果index为kNew(值为-1)表示新添加的事件</span></span><br><span class="line">    <span class="comment">//kNew表示以前监听过这个事件，然后取消监听了，现在可以再次监听</span></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == kNew)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) == channels_.<span class="built_in">end</span>());</span><br><span class="line">      channels_[fd] = channel;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// index == kDeleted</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());</span><br><span class="line">      <span class="built_in">assert</span>(channels_[fd] == channel);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">    <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    (<span class="type">void</span>)fd;</span><br><span class="line">    <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">assert</span>(channels_[fd] == channel);</span><br><span class="line">    <span class="built_in">assert</span>(index == kAdded);</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;<span class="built_in">isNoneEvent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">	  channel-&gt;<span class="built_in">set_index</span>(kDeleted);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">update</span>(EPOLL_CTL_MOD, channel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="type">int</span> operation, Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">  <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line">  event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">  event.data.ptr = channel;   <span class="comment">//保存Channel的指针</span></span><br><span class="line">  <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">&quot;epoll_ctl op = &quot;</span> &lt;&lt; <span class="built_in">operationToString</span>(operation)</span><br><span class="line">    &lt;&lt; <span class="string">&quot; fd = &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot; event = &#123; &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">eventsToString</span>() &lt;&lt; <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (operation == EPOLL_CTL_DEL)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">&quot;epoll_ctl op =&quot;</span> &lt;&lt; <span class="built_in">operationToString</span>(operation) &lt;&lt; <span class="string">&quot; fd =&quot;</span> &lt;&lt; fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSFATAL &lt;&lt; <span class="string">&quot;epoll_ctl op =&quot;</span> &lt;&lt; <span class="built_in">operationToString</span>(operation) &lt;&lt; <span class="string">&quot; fd =&quot;</span> &lt;&lt; fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>updateChannel</code>的核心就是根据channel来对fd更新事件，其实也就是根据index来判断。而<code>update</code>就是完成最后一步的工作，调用<code>epoll_ctl</code>去设置和更新事件，并且通过event.data.ptr保存Channel。</p>
<p>最后来看其中的核心<code>fillActiveChannels</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList* activeChannels)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(numEvents) &lt;= events_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//struct epoll_event 结构中的data.ptr保存的就是Channel的指针</span></span><br><span class="line">    Channel* channel = <span class="built_in">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    ChannelMap::const_iterator it = channels_.<span class="built_in">find</span>(fd);</span><br><span class="line">    <span class="built_in">assert</span>(it != channels_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">assert</span>(it-&gt;second == channel);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">    activeChannels-&gt;<span class="built_in">push_back</span>(channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成的工作很简单，其实就是通过<code>epoll_wait</code>拿到事件集合，然后将其中event.data.ptr保存的Channel指针放入EventLoop传过来的activeChannels。</p>
<p>所以现在我们根据Reactor模型，就可以猜测EventLoop到底在做什么：我们通过EventLoop向Poller注册Channel，然后在EventLoop的事件循环当中，通过Poller的<code>poll</code>调用<code>epoll_wait</code>等待事件，然后通过返回的activeChannels进行事件回调。</p>
<p>这是行得通的，但是在muduo中为了更好的使用Channel，所以又对Channel封装了Acceptor、Connector、TCPConnection，在这篇文章里只先分析Acceptor。</p>
<h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>这个类名的含义也显而易见，究其根源就是封装了Channel，最后调用了<code>accpet</code>来接收一个新的连接。</p>
<p>来先看它的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span> (<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport);</span><br><span class="line">  ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">  </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> listenning_; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;			<span class="comment">// channle所属的事件循环</span></span><br><span class="line">  Socket acceptSocket_;		<span class="comment">// 对应的socket</span></span><br><span class="line">  Channel acceptChannel_;	<span class="comment">// socket的channel</span></span><br><span class="line">  NewConnectionCallback newConnectionCallback_;  <span class="comment">// accept后调用的用户回调函数</span></span><br><span class="line">  <span class="type">bool</span> listenning_;			<span class="comment">// 是否处于监听状态</span></span><br><span class="line">  <span class="type">int</span> idleFd_;				<span class="comment">// 空闲文件描述符，为了防止文件句柄到达上限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口的定义也非常清晰，其中loop就是当前acceptChannel所持有的那个loop，而Socket本质上也就是对linux socket api的一个封装。</p>
<p>我们先来看Acceptor的<code>constructor</code>和<code>listen</code>：</p>
<h3 id="constructor和listen"><a href="#constructor和listen" class="headerlink" title="constructor和listen"></a>constructor和listen</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">  : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>(listenAddr.<span class="built_in">family</span>())),</span><br><span class="line">    <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">    <span class="built_in">listenning_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))  </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReusePort</span>(reuseport);</span><br><span class="line">  acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr);</span><br><span class="line">  acceptChannel_.<span class="built_in">setReadCallback</span>(boost::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();		 </span><br><span class="line">  listenning_ = <span class="literal">true</span>;</span><br><span class="line">  acceptSocket_.<span class="built_in">listen</span>();			 </span><br><span class="line">  acceptChannel_.<span class="built_in">enableReading</span>();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，就是创建一个Socket，并且通过这个Socket创建一个Channel，并且设置相关参数。在这里向acceptChannel设置读事件回调，并且在调用了<code>listen</code>之后向EventLoop和Poller注册了事件和事件回调。</p>
<h3 id="handleRead"><a href="#handleRead" class="headerlink" title="handleRead"></a>handleRead</h3><p>很显然这里的事件回调就是处理新连接到达之后的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  InetAddress peerAddr;		<span class="comment">//对方地址</span></span><br><span class="line">  <span class="comment">//FIXME loop until no more</span></span><br><span class="line">  <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_)   </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">      sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (errno == EMFILE)  </span><br><span class="line">    &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);   </span><br><span class="line">      idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据一开始我们讲解的muduo的事件处理模型，这里应该会将不同的连接分入不同的subReactor，但是这里是调用了创建类时传入的<code>newConnectionCallback_</code>，因为在这个位置是一个很重要的处理位置，也就是三个半事件中的一个，所以应该处理用户传入的回调。当然这里的<code>newConnectionCallback_</code>也是被wrap过的，所以它依旧会将不同的连接分入不同的subReactor。这里在后面看TCPServer的时候再详细解释。</p>
<p>所以现在我们的准备工作都已经做完了，可是正式来看EventLoop了。</p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop是muduo中最重要的一个类，因为里面涉及了一些设计，所以代码也相对的复杂。</p>
<p>所以，我们先看这篇文章中涉及的部分，之后其它内容在后续文章呈现。</p>
<p>首先来看它的接口设计<em><strong>（省略一大部分）</strong></em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> : boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>()&gt; Functor;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">EventLoop</span>();</span><br><span class="line">  ~<span class="built_in">EventLoop</span>(); </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Timestamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pollReturnTime_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// internal usage</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;  <span class="comment">// 在poller中增加或更新通道</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;  <span class="comment">// 1从poller中移除通道</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">eventHandling</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> eventHandling_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> EventLoop* <span class="title">getEventLoopOfCurrentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">abortNotInLoopThread</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> looping_; <span class="comment">/* atomic */</span>	<span class="comment">// 是否处于循环</span></span><br><span class="line">  <span class="type">bool</span> quit_; <span class="comment">/* atomic and shared between threads, okay on x86, I guess. */</span></span><br><span class="line">  <span class="type">bool</span> eventHandling_; <span class="comment">/* atomic */</span>  <span class="comment">// 是否处于事件处理状态</span></span><br><span class="line">  <span class="type">int64_t</span> iteration_;</span><br><span class="line">  <span class="type">const</span> <span class="type">pid_t</span> threadId_;	<span class="comment">// 当前对象所属线程ID</span></span><br><span class="line">  Timestamp pollReturnTime_;  <span class="comment">// 调用poll函数所返回的时间戳</span></span><br><span class="line">  boost::scoped_ptr&lt;Poller&gt; poller_;    <span class="comment">// 只能指针对象，管理poller</span></span><br><span class="line"></span><br><span class="line">  ChannelList activeChannels_;      <span class="comment">// 当前返回的活动通道集合</span></span><br><span class="line">  Channel* currentActiveChannel_;   <span class="comment">// 当前正在处理的活动通道</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>updateChannel</code>、<code>removeChannel</code>、<code>hasChannel</code>都是直接调用Poller提供的接口，在之前Poller部分也分析过了，大家可以自行看代码。</p>
<p>所以，我们可以直接看EventLoop最核心的事件循环<code>loop</code>，有了之前的讲解，对<code>loop</code>的理解会非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!looping_);	</span><br><span class="line">  <span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  looping_ = <span class="literal">true</span>;</span><br><span class="line">  quit_ = <span class="literal">false</span>;  <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; start looping&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.<span class="built_in">clear</span>();   </span><br><span class="line">    pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line"></span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (ChannelList::iterator it = activeChannels_.<span class="built_in">begin</span>();</span><br><span class="line">        it != activeChannels_.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = *it;  </span><br><span class="line">      currentActiveChannel_-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = <span class="literal">NULL</span>;   </span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;    </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">doPendingFunctors</span>();   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">&quot;EventLoop &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; stop looping&quot;</span>;</span><br><span class="line">  looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，<code>loop</code>不断通过<code>Poller::poll</code>获得此时触发事件的Channel，然后直接调用Channel的<code>handleEvent</code>进行处理。但是这里有一个<code>doPendingFunctors</code>，它被用来处理计算任务和定时任务等，详细且听下篇分解。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>所以这么一细看来，muduo的类设计和逻辑都非常清晰。我们简单的总结一下：</p>
<p>Channel本质上就是对fd和event以及event handler的封装，Acceptor则是对Channel的封装，主要功能就是来负责新连接的accept。</p>
<p>而EPollPoller则是<code>epoll</code>相关操作的封装，我们通过传递Channel到Poller中来对关注的事件进行设置和更新，而在EventLoop中的<code>loop</code>则主要是不断通过<code>Poller::poll</code>获得此时触发事件的Channel，然后直接调用Channel的<code>handleEvent</code>进行处理。</p>
<p>所以这里最后的疑问就是：谁来负责创建和传递Channel呢？且看下篇分解。</p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/muduo/" rel="tag">muduo</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag">源码解析</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    dejavudwh
  </span>
</footer>
    </div>
  </body>
</html>