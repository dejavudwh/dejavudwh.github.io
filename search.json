[{"title":"muduo源码解析：EventLoop","date":"2022-05-07T13:36:01.000Z","url":"/2022/05/07/muduo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9AEventLoop/","tags":[["muduo","/tags/muduo/"],["源码解析","/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"]],"categories":[["muduo源码解析","/categories/muduo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"]],"content":"本系列文章主要对muduo的核心源码进行解析。 在正式看muduo源代码之前，必须先理解Reactor模型。 Reactor模型1服务器端程序一般要处理三类事件：IO事件、信号及定时事件，由此延申出来的就有两种关于如何处理这三类事件的事件处理模型：Reactor和Proactor。这里主要讨论Reactor。 Reactor模型本质上主线程***（main reactor)***只负责监听Socket fd上是否有事件发生，有的立即通知工作线程进行处理，也就是说接受新连接、读写数据，业务逻辑均在工作线程中。 使用同步IO模型（以epoll为例）实现的Reactor模型的工作流程是： 主线程往epoll内核事件表中注册socket上的读就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上可读事件发生时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列，由工作线程进行消费。 工作线程从socket上读取数据，处理业务逻辑，然后往epoll内核事件表上注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket上可写事件发生时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列，由工作线程进行消费。 工作线程向socket写入响应消息。 所以Reactor模型一般包含几个组件：句柄（Handle)、事件多路分发器（EventDmultiplexer)、事件处理器（EventHandler）和Reactor。 Reactor是整个框架的核心，Reactor执行事件循环，由用户通过Reactor向事件多路分发器注册事件，句柄也就是统一事件源，当内核检测到就绪事件时，它将通过句柄来通知事件，再由事件多路分发器通过epoll_wait等来分发事件到Reactor，最后再由Reactor调用相应的事件处理器。 muduo的事件模型muduo的事件模型是one loop per thread + threadpool。 也就是说，在多线程下，muduo的每一个子线程都会有一个由mainReactor创建的subReactor，也就是一个事件循环，而其中的被分配到subReactor的socket中的事件和业务逻辑也都由subReactor的子线程进行处理。 所以在多线程下，muduo的工作流程和上面所说的流程的主要区别是： 主线程的事件循环中只监听新连接的事件，并且将新连接根据Round-Robin分配到subReactor中的事件循环。 在此后由该socket触发的事件包括计算任务都由当前subReactor进行处理。 Channel和事件循环相关的类主要有Channel、Acceptor、Poller、EventLoop。Channel是其它类的基础，所以先来分析一个Channel这个类。 Channel主要是对fd和统一事件源及其对应的事件处理的封装。1 Channel的成员变量如下，意义都比较明显，index_和tied_后面分析。 Channel的成员函数最重要的就是事件处理函数handleEvent和设置和取消所关注的事件的一些系列函数enable...()和disable...()。 handleEvent我们要知道，Channel封装的是fd和事件及其事件处理回调，所以显然handleEvent会被在例如epoll_wait返回之后的事件循环中调用，看一下源码： tie和tied_在这里就发挥了作用，它的作用就是延长Channel的生命周期，详细我们仍然按住不表，到后面分析TCPConnection的时候再看。 所以这里会继续调用handleEventWithGuard，逻辑也会很清晰，即根据事件来调用回调函数。1 update和remove接下来比较重要的函数就是update和remove，根据函数名字显然易见，一个是更新关注的事件，一个是移除当前Channl（也就是不关注所有事件了）。 其中update函数在enable...()和diable...()系列函数之后调用，也就是先对更改事件，然后再真正的去内核事件表中进行更新，省掉一些重复代码。 可以看到这里更新和删除Channel最后都是调用EventLoop的函数，其中EventLoop再去调用Poller提供的接口。所以接下来看一下Poller类。 Poller在muduo里提供了epoll和poll来做多路复用，默认使用epoll。所以Poller类是这两个类的父类，这里我们主要关注EPollPoller。 EPollPoller的设计非常简洁，接口如下： 接口的含义都非常明显，其中poll就是相当于调用epoll_wait等待事件返回，由EventLoop调用，然后通过fillActiveChannels去填充EventLoop传进来的activeChannels，而EventLoop则根据这个List去处理回调。 先来看removeChannel操作： 逻辑非常的清晰，先从Poller所持有的channels_删除当前Channel，再从epoll中删除当前channel关注的事件。这里就可以体现之前Channel中index的作用了，主要用来标志当前的Channel是新添加、被删除还是一个正在监听的Channel。注意，这里的remove并不会真正的删除channel，这里后面再解释。 再看updateChannel和update： 而updateChannel的核心就是根据channel来对fd更新事件，其实也就是根据index来判断。而update就是完成最后一步的工作，调用epoll_ctl去设置和更新事件，并且通过event.data.ptr保存Channel。 最后来看其中的核心fillActiveChannels： 完成的工作很简单，其实就是通过epoll_wait拿到事件集合，然后将其中event.data.ptr保存的Channel指针放入EventLoop传过来的activeChannels。 所以现在我们根据Reactor模型，就可以猜测EventLoop到底在做什么：我们通过EventLoop向Poller注册Channel，然后在EventLoop的事件循环当中，通过Poller的poll调用epoll_wait等待事件，然后通过返回的activeChannels进行事件回调。 这是行得通的，但是在muduo中为了更好的使用Channel，所以又对Channel封装了Acceptor、Connector、TCPConnection，在这篇文章里只先分析Acceptor。 Acceptor这个类名的含义也显而易见，究其根源就是封装了Channel，最后调用了accpet来接收一个新的连接。 来先看它的接口： 接口的定义也非常清晰，其中loop就是当前acceptChannel所持有的那个loop，而Socket本质上也就是对linux socket api的一个封装。 我们先来看Acceptor的constructor和listen： constructor和listen 总的来说，就是创建一个Socket，并且通过这个Socket创建一个Channel，并且设置相关参数。在这里向acceptChannel设置读事件回调，并且在调用了listen之后向EventLoop和Poller注册了事件和事件回调。 handleRead很显然这里的事件回调就是处理新连接到达之后的操作： 根据一开始我们讲解的muduo的事件处理模型，这里应该会将不同的连接分入不同的subReactor，但是这里是调用了创建类时传入的newConnectionCallback_，因为在这个位置是一个很重要的处理位置，也就是三个半事件中的一个，所以应该处理用户传入的回调。当然这里的newConnectionCallback_也是被wrap过的，所以它依旧会将不同的连接分入不同的subReactor。这里在后面看TCPServer的时候再详细解释。 所以现在我们的准备工作都已经做完了，可是正式来看EventLoop了。 EventLoopEventLoop是muduo中最重要的一个类，因为里面涉及了一些设计，所以代码也相对的复杂。 所以，我们先看这篇文章中涉及的部分，之后其它内容在后续文章呈现。 首先来看它的接口设计（省略一大部分）： 其中updateChannel、removeChannel、hasChannel都是直接调用Poller提供的接口，在之前Poller部分也分析过了，大家可以自行看代码。 所以，我们可以直接看EventLoop最核心的事件循环loop，有了之前的讲解，对loop的理解会非常简单： 很显然，loop不断通过Poller::poll获得此时触发事件的Channel，然后直接调用Channel的handleEvent进行处理。但是这里有一个doPendingFunctors，它被用来处理计算任务和定时任务等，详细且听下篇分解。 总结：所以这么一细看来，muduo的类设计和逻辑都非常清晰。我们简单的总结一下： Channel本质上就是对fd和event以及event handler的封装，Acceptor则是对Channel的封装，主要功能就是来负责新连接的accept。 而EPollPoller则是epoll相关操作的封装，我们通过传递Channel到Poller中来对关注的事件进行设置和更新，而在EventLoop中的loop则主要是不断通过Poller::poll获得此时触发事件的Channel，然后直接调用Channel的handleEvent进行处理。 所以这里最后的疑问就是：谁来负责创建和传递Channel呢？且看下篇分解。"},{"title":"about","date":"2022-05-06T09:17:12.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"dejavudwh,"},{"title":"category","date":"2022-05-06T09:16:54.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"about","date":"2022-05-06T09:17:12.000Z","url":"/404.html","categories":[[" ",""]],"content":"dejavudwh,"},{"title":"search","date":"2022-05-08T03:41:46.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2022-05-08T03:46:41.000Z","url":"/tags/index.html","categories":[[" ",""]]}]